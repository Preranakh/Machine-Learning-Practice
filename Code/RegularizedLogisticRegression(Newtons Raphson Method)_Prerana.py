# -*- coding: utf-8 -*-
"""prob3(RegularizedLR)_Khatiwada.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TUkxpA7L4NtG_MjtO2TGOuC2wrA7gZSB
"""

import scipy.io
import numpy as np
import matplotlib
from sklearn.model_selection import train_test_split
from matplotlib import pyplot as plt
##Loading Dataset
data = scipy.io.loadmat('mnist_49_3000.mat')
x1 = np.array(data['x'])
y = np.array(data['y'][0])
y[y==-1] = 0

x.shape,y.shape

x = np.vstack([np.ones((1,3000)), x1])
x_train = x[:,:2000]
x_test = x[:,2000:]
y_train = y[:2000]
y_test = y[2000:]

x_train.shape,x_test.shape,y_train.shape,y_test.shape

#calculating the gradient
def sigmoid(theta,xi):
  return (1/(1+np.exp(-theta.T.dot(xi))))[0][0]

def grad(theta,x_train,y_train):
  lambdaa = 10
  gradient = 2*lambdaa*theta
  hessian = 2*lambdaa*np.eye(x.shape[0])
  n = 2000
  for i in range(2000):
    current_data = x_train[:,i].reshape(-1,1)
    gradient += (current_data*(sigmoid(theta,current_data)-y_train[i]))
    hessian +=np.outer(current_data,current_data)*(sigmoid(theta,current_data))*(1-sigmoid(theta,current_data))
  return gradient, hessian

#newton's method
theta = np.zeros((x.shape[0],1))
for i in range(5):
  g,h = grad(theta,x_train,y_train)
  theta-= np.linalg.inv(h).dot(g)

prob=[]

for i in range(1000):
  current_data = x_test[:,i].reshape(-1,1)
  prob.append(sigmoid(theta,current_data))
prob = np.array(prob)
y_pred = (prob>0.5)*1.0

sigmoid_prob = sigmoid(theta, x_train)
loglike= np.sum(np.dot(y_train,np.log(sigmoid_prob)) + np.dot((1-y_train),np.log(1- sigmoid_prob)))


print("No of correctly classified images is:",sum(y_pred==y_test))
print("The value of the objective function at the optimum is:", loglike)
Test_Accuracy=100*sum(y_pred==y_test)/(len(y_test))
Test_Error = 100-100*sum(y_pred==y_test)/(len(y_test))
print('Test Accuracyis:' , Test_Accuracy)
print('Test Error is:' , Test_Error)

"""Optimization Criteria--I ran the code for range 1,2,3,4,5 and so on and in each pass/iteration I get the same value of my objective function so,I took 5 as my termination criteria."""

img_misclassified=np.zeros((100,1))
j=0
show_prob=np.zeros((1000,1))
for i in range (1000):
  if y_pred[i] !=y_test[i]:
    if prob[i]>=0.8 or prob[i]<=0.2:
     img_misclassified[j]=i
     print(img_misclassified[j][0], prob[i])
     show_prob[j]=np.copy(prob[i])
     j=j+1
print (j)

posn=0
for i in range (j-5):
  posn= img_misclassified[i][0]
  posn=int(posn)+2000
  image = x1[:,posn].reshape(28,28)
  plt.imshow(image, interpolation='nearest')
  plt.show()

